import{p as C,f as u,I as g,J as P,K as b,w as k,l as z,u as A}from"./entry-6cefe8ec.mjs";const O=e=>C(e)?e:u(e),R=()=>null;function B(...e){var y,h,v,m,D,_,w;const i=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&e.unshift(i);let[t,f,a={}]=e;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof f!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");a.server=(y=a.server)!=null?y:!0,a.default=(h=a.default)!=null?h:R,a.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),a.lazy=(m=(v=a.lazy)!=null?v:a.defer)!=null?m:!1,a.initialCache=(D=a.initialCache)!=null?D:!0;const n=g(),l=z();if(l&&!l._nuxtOnBeforeMountCbs){const s=l._nuxtOnBeforeMountCbs=[];l&&(P(()=>{s.forEach(o=>{o()}),s.splice(0,s.length)}),b(()=>s.splice(0,s.length)))}const c=()=>a.initialCache&&n.payload.data[t]!==void 0,r={data:O((_=n.payload.data[t])!=null?_:a.default()),pending:u(!c()),error:u((w=n.payload._errors[t])!=null?w:null)};r.refresh=(s={})=>n._asyncDataPromises[t]?n._asyncDataPromises[t]:s._initial&&c()?n.payload.data[t]:(r.pending.value=!0,n._asyncDataPromises[t]=Promise.resolve(f(n)).then(o=>{a.transform&&(o=a.transform(o)),a.pick&&(o=I(o,a.pick)),r.data.value=o,r.error.value=null}).catch(o=>{r.error.value=o,r.data.value=A(a.default())}).finally(()=>{r.pending.value=!1,n.payload.data[t]=r.data.value,r.error.value&&(n.payload._errors[t]=!0),delete n._asyncDataPromises[t]}),n._asyncDataPromises[t]);const d=()=>r.refresh({_initial:!0}),x=a.server!==!1&&n.payload.serverRendered;{x&&n.isHydrating&&t in n.payload.data?r.pending.value=!1:l&&n.payload.serverRendered&&(n.isHydrating||a.lazy)?l._nuxtOnBeforeMountCbs.push(d):d(),a.watch&&k(a.watch,()=>r.refresh());const s=n.hook("app:data:refresh",o=>{if(!o||o.includes(t))return r.refresh()});l&&b(s)}const p=Promise.resolve(n._asyncDataPromises[t]).then(()=>r);return Object.assign(p,r),p}function E(...e){const i=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&e.unshift(i);const[t,f,a]=e;return B(t,f,{...a,lazy:!0},null)}function H(e){const i=e?Array.isArray(e)?e:[e]:void 0;return g().callHook("app:data:refresh",i)}function I(e,i){const t={};for(const f of i)t[f]=e[f];return t}export{E as a,H as r,B as u,O as w};
